\documentclass[a4paper]{article}
\usepackage{listings}
\usepackage{amsmath}
\newcommand*{\code}[1]{\texttt{#1}}

\begin{document}

\section{Architecture}

The program consists of the following components:

\paragraph*{Scanner:} The scanner has one public method: \code{getToken}, 
which scans and returns the next token from the program. The 
constructor takes references to the program string and an 
\code{ErrorHandler}, to which it passes any lexical errors it finds.
A \code{Token} is a data structure that contains the a \code{value} and 
a \code{span}: which positions of the code it covers.
The value of a token can be an integer/string literal, 
identifier, keyword, operator or punctuation.

\paragraph*{Parser:}

\paragraph*{ErrorHandler:}

\paragraph*{TypeChecker:}

\paragraph*{InterpreterVisitor:}



\section{Token patterns}

\begin{itemize}
  \item Identifiers and reserved keywords
  \item String literals
  \item Integer constants
  \item Operators
  \item Comments
  \item Other
\end{itemize}

\section{Parsing}

\subsection{Context-free grammar}


\newcommand{\cfgvar}[1]{$<$#1$>$}
\newcommand{\cfgrule}[2]{\text{\cfgvar{#1}} &\rightarrow \text{#2}}
\newcommand{\cfgterm}[1]{\textbf{#1}}
The terminals are \cfgvar{literal}, \cfgvar{op}, \cfgvar{ident}, 
\cfgvar{unary$\_$op}, the end-of-file symbol \$\$, punctuation 
and the bolded keywords.
\begin{align*}
  \cfgrule{prog}{\cfgvar{stmts} \$\$} \\
  \cfgrule{stmts}{\cfgvar{stmt} \cfgvar{stmts} $\mid$ $\varepsilon$} \\
  \cfgrule{stmt}{\cfgvar{decl} $\mid$ 
                 \cfgvar{assign} $\mid$
                 \cfgvar{for} $\mid$ 
                 \cfgvar{read} $\mid$ 
                 \cfgvar{print} $\mid$ 
                 \cfgvar{if} } \\
  \cfgrule{decl}{
    \cfgterm{var} \cfgvar{ident} : \cfgvar{type} \cfgvar{delc\_assign}
  } \\
  \cfgrule{decl\_assign}{
     := \cfgvar{expr} $\mid$ $\varepsilon$
  }\\
  \cfgrule{assign}{
    \cfgvar{ident} := \cfgvar{expr}
  } \\
  \cfgrule{for}{
    \cfgterm{for} \cfgvar{ident} \cfgterm{in} 
    \cfgvar{expr}..\cfgvar{expr} \cfgterm{do} \cfgvar{stmts} 
    \cfgterm{end for}
  } \\
  \cfgrule{read}{
    \cfgterm{read} \cfgvar{ident}
  } \\
  \cfgrule{print}{
    \cfgterm{print} \cfgvar{expr}
  } \\ 
  \cfgrule{if}{
    \cfgterm{if} \cfgvar{expr} \cfgterm{do} \cfgvar{stmts}
    \cfgvar{else} \cfgterm{end if}
  } \\
  \cfgrule{else}{
    \cfgterm{else} \cfgvar{stmts} $\mid$ $\varepsilon$
  } \\
  \cfgrule{expr}{ 
    \cfgvar{opnd} \cfgvar{expr$\_$tail} 
    $\mid$ \cfgvar{unary$\_$op} \cfgvar{opnd}
  } \\
  \cfgrule{expr$\_$tail}{
    \cfgvar{op} \cfgvar{opnd} $\mid$ $\varepsilon$
  } \\
  \cfgrule{opnd}{
    \cfgvar{literal} $\mid$ \cfgvar{ident} 
    $\mid$ \cfgterm{(} \cfgvar{expr} \cfgterm{)}
  } \\
\end{align*}

\clearpage
\section{Abstract Syntax Trees}

All AST-nodes inherit the \code{AstNodeBase} class, which contains 
a \code{Span} for error messages. The type \code{AstNode} is a 
\code{std::variant} which may contain an AST-node of any of the 
following types:

\begin{itemize}
  \item \code{DeclAstNode}: a declaration.
  \begin{itemize}
    \item[] \code{VarIdent varId}
    \item[] \code{Type type} 
    \item[] \code{optional<ExprAstNode> expr}
  \end{itemize}
  \item \code{AssignAstNode}: assignment
  \begin{itemize}
    \item[] \code{VarIdent varId}
    \item[] \code{ExprAstNode expr}
  \end{itemize}
  \item \code{ForAstNode}: for-statement
  \begin{itemize}
    \item[] \code{VarIdent varId}: loop variable
    \item[] \code{ExprAstNode startExpr, endExpr}: start and end of the range
    \item[] \code{StatementsAstNode stmts}: the statements inside the loop
  \end{itemize}
  \item \code{IfAstNode}: if-statement
  \begin{itemize}
    \item[] \code{ExprAstNode expr}
    \item[] \code{StatementsAstNode ifStatements}
    \item[] \code{StatementsAstNode elseStatements}
  \end{itemize}
  \item \code{ReadAstNode}: read-statement
  \begin{itemize}
    \item[] \code{VarIdent varId}
  \end{itemize}
  \item \code{PrintAstNode}: print-statement
  \begin{itemize}
    \item[] \code{ExprAstNode expr}
  \end{itemize}
  \item \code{StatementsAstNode}: a list of statements
  \begin{itemize}
    \item[] \code{vector<AstNode> stmts}: list of statements
  \end{itemize}
  \item \code{ExprAstNode}: expression
  \begin{itemize}
    \item[] \code{Operator op}: enum storing the operator
    \item[] \code{OpndAstNode *opnd1}
    \item[] \code{OpndAstNode *opnd2}: null for unary operands.
  \end{itemize}
  \item \code{OpndAstNode}: operand
  \begin{itemize}
    \item[] \code{Operand opnd}, which is one of 
    \code{Literal, VarIdent, ExprAstNode}
  \end{itemize}
\end{itemize}


\section{Error handling}

All components are given a reference to the \code{ErrorHandler}, 
which they use to raise errors when something unexpected happens.
The \code{ErrorHandler} prints out error messages and keeps track 
of whether errors have been encountered. 
The components then do something component-specific to recover and 
continue processing the input program. If the \code{ErrorHandler} 
has errors after the scanning and parsing passes, the interpreter 
ends the process. Otherwise it continues with semantic analysis 
and finally runs the program.

The \code{Scanner} always returns a token when asked, whether or 
not it runs into errors while processing. When a problem is 
encountered and the current token can not be scanned, the scanner 
skips it and scans the next token (after raising an error to the 
handler). In some cases, e.g. when encountering a newline while 
scanning a string, the \code{Scanner} can return the the token it 
was scanning while the error happened. When the end of the 
program has been reached, the Scanner returns an end-of-file token.

The parser has an exception-based racovery approach. When the 
\code{match}-function can not match the current token, an error 
is raised and an exception thrown. The exception is caught 
in the \code{statements} function, and tokens are skipped until
the current token is a semicolon or one of the keywords 
\textbf{var}, \textbf{for}, \textbf{read}, \textbf{print}, 
or \textbf{if}. The parser uses these to find the start of a 
new statements and resumes parsing from that point.

\section{Testing}

Automated testing of the interpreter was implemented with the 
googletest framework. The scanner is well tested with unit tests 
covering all different token types, while other components have 
only a few limited unit tests. The whole system is tested with 
integration tests that check whether running the test programs 
produces the expected behaviour. 

There are no automatic tests for the error handling and recovery 
functionalities. These were tested by hand, by running the incorrect 
sample programs and looking at the output.

\end{document}